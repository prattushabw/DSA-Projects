/**
 * The StoryTreeNode class  represents the primary data structure for the Zork game.
 * This class should be a ternary (3-child) tree of StoryTreeNodes
 *
 * @author Prattusha Biswas 114587992, and recitation 02
 */

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.zip.DataFormatException;
public class StoryTree {

    /**
     * The root node of the story tree.
     */
    static StoryTreeNode root;

    /**
     * The current node in the story tree.
     */
    static StoryTreeNode cursor;

    /**
     * The current state of the game.
     */
    GameState state;

    /**
     * The story tree instance.
     */
    static StoryTree tree = new StoryTree();

    /**
     * Creates a new instance of the StoryTree class with default values.
     */
    public StoryTree() {
        root = new StoryTreeNode("root", "root", "Hello and Welcome to Zork!");
        cursor = root;
        this.state = GameState.GAME_NOT_OVER;
    }

    /**
     * Creates a new instance of the StoryTree class with the specified values.
     *
     * @param position The position of the node.
     * @param option   The option of the node.
     * @param message  The message of the node.
     */
    public StoryTree(String position, String option, String message) {
        root = new StoryTreeNode(position, option, message);
        state = GameState.GAME_NOT_OVER;
        cursor = root;
    }


    /**
     * Reads in a text file describing a StoryTree. See sample input for an example.
     *
     * @param filename The name of the file to read from.
     * @return A new StoryTree generated by the passed in text file is returned.
     * @throws IllegalArgumentException If filename is empty or null.
     * @throws DataFormatException      If the file contained data inconsistent with the expected data format.
     * @throws FileNotFoundException    If the specified file does not exist.
     */
    public static StoryTree readTree(String filename) throws DataFormatException, FileNotFoundException {
        try {
            if (filename.isEmpty() || filename == null) {
                throw new IllegalArgumentException();
            }

            FileReader reader = new FileReader(filename);
            Scanner input = new Scanner(reader);
            String line;

            while (input.hasNextLine()) {
                line = input.nextLine();
                String[] newLine = line.split(" \\| ");

                if (newLine.length != 3) {
                    throw new DataFormatException();
                }

                StoryTreeNode newTree = new StoryTreeNode(newLine[0], newLine[1], newLine[2]);

                // int counter = 0;
                if (!newLine[0].contains("-")) {

                    for (int i = 0; i < newLine[0].length(); i++) {
                        if (newLine[0].charAt(i) == '1' || newLine[0].charAt(i) == '2' || newLine[0].charAt(i) == '3') {
                            // counter++;
                            tree.addChild(newLine[1], newLine[2]);
                        }
                    }
                } else {
                    // String num = newLine[0].replace("-", "");
                    String[] formattedPosition = newLine[0].split("-");
                    //for (int j = 0; j < newLine.length; j++) {
                    tree.resetCursor();
                    /* for (String s : formattedPosition) {
                            System.out.print(s);
                        }
                        System.out.println();*/
                    for (int i = 0; i < formattedPosition.length - 1; i++) {
                        if ((formattedPosition[i].equals("1"))) {
                            tree.selectChild("1");
                            // tree.addChild(newLine[1], newLine[2]);
                        } else if (formattedPosition[i].equals("2")) {
                            tree.selectChild("2");
                            //   tree.addChild(newLine[1], newLine[2]);
                        } else if (formattedPosition[i].equals("3")) {
                            tree.selectChild("3");
                            //  tree.addChild(newLine[1], newLine[2]);
                        }
                    }
                    tree.addChild(newLine[1], newLine[2]);
                    //   tree.setCursorOption(newTree.getOption());
                    // tree.setCursorMessage(newTree.getMessage());
                }
            }
            tree.resetCursor();

        } catch (TreeFullException ex) {
            System.out.println("Tree is full.");
        } catch (NodeNotPresentException ex) {
            System.out.println("Node is not present");
        } catch(FileNotFoundException e){
            tree= new StoryTree("root","root","Hello, and Welcome to Zork!");
        }
        return tree;
    }

    /**
     * Saves the current state of the story tree to a file.
     *
     * If the filename or the tree is null or empty, an IllegalArgumentException is thrown. The tree is traversed in
     * preorder starting from the root, and each node's position, option, and message are saved to the file in the
     * following format: position | option | message.
     * @param filename The name of the file to save the tree to.
     * @param tree The story tree to save.
     * @throws IOException If an I/O error occurs while writing to the file.
     */

    public static void saveTree(String filename, StoryTree tree) throws IOException {
        if (tree == null && filename == null || filename.isEmpty()) {
            throw new IllegalArgumentException();
        } else {
            tree.resetCursor();
            // File story = new File(filename);
            PrintWriter writer = new PrintWriter(filename);
            tree.preOrder(cursor.leftChild, writer);
            writer.close();
        }
    }


    /**
     * Traverses the tree from the specified node and saves the data to the given writer.
     * @param node The node to start the traversal from.
     * @param writer The writer to save the data to.
     */
    private void preOrder(StoryTreeNode node, PrintWriter writer) {
        if (node == null)
            return;
//        if(node.isWinningNode() || node.isLosingNode()){
//            return;
//        }
        writer.printf("%s | %s | %s%n", node.getPosition(), node.getOption(), node.getMessage());
        preOrder(node.getLeftChild(), writer);
        preOrder(node.getMiddleChild(), writer);
        preOrder(node.getRightChild(), writer);
    }


    /**
     * Selects the child node at the specified position.
     * If the position is null or empty, an IllegalArgumentException is thrown. If the node at the specified position
     * does not exist, a NodeNotPresentException is thrown.
     * @param position The position of the child node to select.
     * @throws NodeNotPresentException If the node at the specified position does not exist.
     */
    public void selectChild(String position) throws NodeNotPresentException {
        if (position == null || position.isEmpty())
            throw new IllegalArgumentException();
        //   StoryTreeNode pointer = null;
         if (cursor.countChildren()<Integer.parseInt(position)) {
            throw new NodeNotPresentException("Node with indicated position variable cannot be found.");
        }

        if (position.equals("1")) {
                cursor = cursor.getLeftChild();
        } else if (position.equals("2")) {
                cursor = cursor.getMiddleChild();
        } else if (position.equals("3")) {
            cursor = cursor.getRightChild();
        }
    }

    /**
     * Adds a new child node to the current cursor node with the given option and message.
     * Throws an IllegalArgumentException if either option or message is null or empty.
     * Throws a TreeFullException if all three child nodes of the cursor node are already full.
     * @param option the option associated with the new child node
     * @param message the message associated with the new child node
     * @throws TreeFullException if all three child nodes of the cursor node are already full.
     */
    public void addChild(String option, String message) throws TreeFullException {
        if ((option == null || message == null || option.isEmpty() || message.isEmpty())) {
            throw new IllegalArgumentException();
        }
        if (cursor != null) {
            // System.out.println("cursor : " + getCursorMessage());

            if (cursor.getLeftChild() != null && cursor.getMiddleChild() != null && cursor.getRightChild() != null) {
                throw new TreeFullException("All three child spots are already full.");
            }

            if (cursor.getLeftChild() == null) {
                StoryTreeNode newChild = new StoryTreeNode("1", option, message);
                cursor.setLeftChild(newChild);
                if (cursor == root)
                    newChild.setPosition("1");
                else
                    newChild.setPosition(cursor.getPosition() + "-1");
            } else if (cursor.getMiddleChild() == null) {
                StoryTreeNode newChild = new StoryTreeNode("2", option, message);
                cursor.setMiddleChild(newChild);
                newChild.setPosition(cursor.getPosition() + "-2");
            } else if (cursor.getRightChild() == null) {
                StoryTreeNode newChild = new StoryTreeNode("3", option, message);
                cursor.setRightChild(newChild);
                newChild.setPosition(cursor.getPosition() + "-3");
            }
        } else {
            System.out.println("cursor is null.");
        }

    }

    /**
     * Removes the child node at the given position from the current cursor node and returns it.
     * @param position the position of the child node to remove
     * @return the removed child node
     */
    public StoryTreeNode removeChild(String position) throws NodeNotPresentException {
        StoryTreeNode pointer = null;
        if (cursor.countChildren()<Integer.parseInt(position)) {
            throw new NodeNotPresentException("Node with indicated position variable cannot be found.");
        }
        if (position.equals("1")) {
                pointer = cursor.getLeftChild();
                cursor.setLeftChild(cursor.getMiddleChild());
                cursor.setMiddleChild(cursor.getRightChild());
                cursor.setRightChild(null);
        } else if (position.equals("2")) {

            pointer = cursor.getMiddleChild();
            cursor.setMiddleChild(cursor.getRightChild());
            cursor.setRightChild(null);
        } else if (position.equals("3")) {
            pointer = cursor.getRightChild();
            cursor.setRightChild(null);
        }
        return pointer;
    }

    /**
     * Returns the current game state based on the current cursor node.
     * @return the current game state
     */
    public GameState getGameState() {
        if (cursor.isWinningNode()) {
            state = GameState.GAME_OVER_WIN;
        } else if (cursor.isLosingNode()) {
            state = GameState.GAME_OVER_LOSE;
        } else {
            state = GameState.GAME_NOT_OVER;
        }
        return state;
    }

    /**
     * Returns the current position of the cursor as a string.
     * @return The current position of the cursor as a string.
     */
    public String[] getCursorPosition() {
        return cursor.getPosition().split("-");
    }

    /**
     * Returns the message associated with the current node that the cursor is pointing to.
     * @return The message associated with the current node that the cursor is pointing to.
     */
    public String getCursorMessage() {
        return cursor.getMessage();
    }

    /**
     * Returns a 2-dimensional array representing the available options for the current node.
     * @return A 2-dimensional array representing the available options for the current node.
     */
    public String[][] getOptions() {
        String[][] option = new String[cursor.countChildren()][2];
        if (cursor.getLeftChild() != null) {
            option[0][0] = cursor.getLeftChild().getPosition();
            option[0][1] = cursor.getLeftChild().getOption();
            // System.out.print( "LEFT"+  option[0][1] );
        }
        if (cursor.getMiddleChild() != null) {
            option[1][0] = cursor.getMiddleChild().getPosition();
            option[1][1] = cursor.getMiddleChild().getOption();
            //  System.out.print( "MIDDLE"+  option[1][1] );
        }
        if (cursor.getRightChild() != null) {
            option[2][0] = cursor.getRightChild().getPosition();
            option[2][1] = cursor.getRightChild().getOption();
            // System.out.print( "RIGHT"+  option[2][1] );
        }

        return option;
    }

    /**
     * Sets the message associated with the current node that the cursor is pointing to.
     * @param message The new message to set.
     */
    public void setCursorMessage(String message) {
        if (message != null) {
            cursor.setMessage(message);
        }
    }

    /**
     * Sets the option associated with the current node that the cursor is pointing to.
     * @param option The new option to set.
     */
    public void setCursorOption(String option) {
        if (option != null) {
            cursor.setOption(option);
        }
    }

    /**
     * Resets the cursor to the root node.
     */
    public void resetCursor() {
        if (root != null) {
            cursor = root;
        }
    }

    /**
     * This method returns the cursor to the root of the StoryTree and
     * then navigates back to the parent of the current cursor position
     */
    public void returnToParent() {
        cursor = root;
        for (int i=0; i<getCursorPosition().length-1; i++) {
            try {
                selectChild(getCursorPosition()[i]);
            } catch (NodeNotPresentException e) {
                System.out.println("Node with indicated position variable cannot be found.");
            }
        }
    }

    /**
     * This method counts the number of leaves in the StoryTree starting at the given node.
     * @param node A StoryTreeNode object representing the node to start counting from.
     * @return A double representing the total number of leaves in the StoryTree.
     */
    public double totalLeaves(StoryTreeNode node) {
        if (node == null) {
            return 0.0;
        }
        double count = 0.0;
        List<StoryTreeNode> nodes = new ArrayList<>();
        nodes.add(node);
        for (int i = 0; i < nodes.size(); i++) {
            StoryTreeNode currNode = nodes.get(i);
            if (currNode.isLeaf()) {
                count += 1.0;
            } else {
                if (currNode.getLeftChild() != null) {
                    nodes.add(currNode.getLeftChild());
                }
                if (currNode.getMiddleChild() != null) {
                    nodes.add(currNode.getMiddleChild());
                }
                if (currNode.getRightChild() != null) {
                    nodes.add(currNode.getRightChild());
                }
            }
        }
        return count;
    }

    /**
     * This method counts the number of winning nodes in the StoryTree starting at the given node.
     * @param node A StoryTreeNode object representing the node to start counting from.
     * @return A double representing the total number of winning nodes in the StoryTree.
     **/
    public double totalWinning(StoryTreeNode node) {
        if (node == null) {
            return 0.0;
        }
        double count = 0.0;
        List<StoryTreeNode> nodes = new ArrayList<>();
        nodes.add(node);
        for (int i = 0; i < nodes.size(); i++) {
            StoryTreeNode currNode = nodes.get(i);
            if (currNode.isWinningNode()) {
                count += 1.0;
            } else {
                if (currNode.getLeftChild() != null) {
                    nodes.add(currNode.getLeftChild());
                }
                if (currNode.getMiddleChild() != null) {
                    nodes.add(currNode.getMiddleChild());
                }
                if (currNode.getRightChild() != null) {
                    nodes.add(currNode.getRightChild());
                }
            }
        }
        return count;
    }

    /**
     * This method calculates the probability of winning the game from the current cursor position in the StoryTree.
     * @return A double representing the probability of winning the game.
     */
    public double winProbability() {
        return totalWinning(cursor)/totalLeaves(cursor);
    }

}
